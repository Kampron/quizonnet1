import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/react-idle-timer/dist/index.esm.js
var import_react = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var Et = Object.create;
var ke = Object.defineProperty;
var bt = Object.getOwnPropertyDescriptor;
var gt = Object.getOwnPropertyNames;
var yt = Object.getPrototypeOf;
var wt = Object.prototype.hasOwnProperty;
var Lt = (r) => ke(r, "__esModule", { value: true });
var Pt = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var kt = (r, e, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of gt(e))
      !wt.call(r, i) && i !== "default" && ke(r, i, { get: () => e[i], enumerable: !(n = bt(e, i)) || n.enumerable });
  return r;
};
var Mt = (r) => kt(Lt(ke(r != null ? Et(yt(r)) : {}, "default", r && r.__esModule && "default" in r ? { get: () => r.default, enumerable: true } : { value: r, enumerable: true })), r);
var $e = Pt((pe, Ye) => {
  (function(r, e) {
    typeof pe == "object" && typeof Ye != "undefined" ? e(pe) : typeof define == "function" && define.amd ? define(["exports"], e) : (r = typeof globalThis != "undefined" ? globalThis : r || self, e(r.fastUniqueNumbers = {}));
  })(pe, function(r) {
    "use strict";
    var e = function(d) {
      return function(h) {
        var o = d(h);
        return h.add(o), o;
      };
    }, n = function(d) {
      return function(h, o) {
        return d.set(h, o), o;
      };
    }, i = Number.MAX_SAFE_INTEGER === void 0 ? 9007199254740991 : Number.MAX_SAFE_INTEGER, c = 536870912, m = c * 2, y = function(d, h) {
      return function(o) {
        var B = h.get(o), w = B === void 0 ? o.size : B < m ? B + 1 : 0;
        if (!o.has(w))
          return d(o, w);
        if (o.size < c) {
          for (; o.has(w); )
            w = Math.floor(Math.random() * m);
          return d(o, w);
        }
        if (o.size > i)
          throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");
        for (; o.has(w); )
          w = Math.floor(Math.random() * i);
        return d(o, w);
      };
    }, C = /* @__PURE__ */ new WeakMap(), W = n(C), p = y(W, C), l = e(p);
    r.addUniqueNumber = l, r.generateUniqueNumber = p, Object.defineProperty(r, "__esModule", { value: true });
  });
});
function Ot(r) {
  return (0, import_react.forwardRef)(function(n, i) {
    let c = { ...n }, m = re(c);
    return typeof i == "function" ? i(m) : i && (i.current = m), import_react.default.createElement(r, { ...n, ...m });
  });
}
var qe = class extends import_react.Component {
};
var je = class extends qe {
  constructor(e) {
    super(e);
    this.onPresenceChange && e.setOnPresenceChange(this.onPresenceChange.bind(this)), this.onPrompt && e.setOnPrompt(this.onPrompt.bind(this)), this.onIdle && e.setOnIdle(this.onIdle.bind(this)), this.onActive && e.setOnActive(this.onActive.bind(this)), this.onAction && e.setOnAction(this.onAction.bind(this)), this.onMessage && e.setOnMessage(this.onMessage.bind(this));
  }
};
var ne = Mt($e());
var Je = (r) => r.method !== void 0 && r.method === "call";
var ze = (r) => r.error === null && typeof r.id == "number";
var Xe = (r) => {
  let e = /* @__PURE__ */ new Map([[0, () => {
  }]]), n = /* @__PURE__ */ new Map([[0, () => {
  }]]), i = /* @__PURE__ */ new Map(), c = new Worker(r);
  return c.addEventListener("message", ({ data: p }) => {
    if (Je(p)) {
      let { params: { timerId: l, timerType: f } } = p;
      if (f === "interval") {
        let d = e.get(l);
        if (typeof d == "number") {
          let h = i.get(d);
          if (h === void 0 || h.timerId !== l || h.timerType !== f)
            throw new Error("The timer is in an undefined state.");
        } else if (typeof d != "undefined")
          d();
        else
          throw new Error("The timer is in an undefined state.");
      } else if (f === "timeout") {
        let d = n.get(l);
        if (typeof d == "number") {
          let h = i.get(d);
          if (h === void 0 || h.timerId !== l || h.timerType !== f)
            throw new Error("The timer is in an undefined state.");
        } else if (typeof d != "undefined")
          d(), n.delete(l);
        else
          throw new Error("The timer is in an undefined state.");
      }
    } else if (ze(p)) {
      let { id: l } = p, f = i.get(l);
      if (f === void 0)
        throw new Error("The timer is in an undefined state.");
      let { timerId: d, timerType: h } = f;
      i.delete(l), h === "interval" ? e.delete(d) : n.delete(d);
    } else {
      let { error: { message: l } } = p;
      throw new Error(l);
    }
  }), { clearInterval: (p) => {
    let l = (0, ne.generateUniqueNumber)(i);
    i.set(l, { timerId: p, timerType: "interval" }), e.set(p, l), c.postMessage({ id: l, method: "clear", params: { timerId: p, timerType: "interval" } });
  }, clearTimeout: (p) => {
    let l = (0, ne.generateUniqueNumber)(i);
    i.set(l, { timerId: p, timerType: "timeout" }), n.set(p, l), c.postMessage({ id: l, method: "clear", params: { timerId: p, timerType: "timeout" } });
  }, setInterval: (p, l) => {
    let f = (0, ne.generateUniqueNumber)(e);
    return e.set(f, () => {
      p(), typeof e.get(f) == "function" && c.postMessage({ id: null, method: "set", params: { delay: l, now: performance.now(), timerId: f, timerType: "interval" } });
    }), c.postMessage({ id: null, method: "set", params: { delay: l, now: performance.now(), timerId: f, timerType: "interval" } }), f;
  }, setTimeout: (p, l) => {
    let f = (0, ne.generateUniqueNumber)(n);
    return n.set(f, p), c.postMessage({ id: null, method: "set", params: { delay: l, now: performance.now(), timerId: f, timerType: "timeout" } }), f;
  } };
};
var ie = null;
var Ke = (r, e) => () => {
  if (ie !== null)
    return ie;
  let n = new Blob([e], { type: "application/javascript; charset=utf-8" }), i = URL.createObjectURL(n);
  return ie = r(i), ie.setTimeout(() => URL.revokeObjectURL(i), 0), ie;
};
var Qe = `(()=>{"use strict";const e=new Map,t=new Map,r=(e,t)=>{let r,o;const i=performance.now();r=i,o=e-Math.max(0,i-t);return{expected:r+o,remainingDelay:o}},o=(e,t,r,i)=>{const s=performance.now();s>r?postMessage({id:null,method:"call",params:{timerId:t,timerType:i}}):e.set(t,setTimeout(o,r-s,e,t,r,i))};addEventListener("message",(i=>{let{data:s}=i;try{if("clear"===s.method){const{id:r,params:{timerId:o,timerType:i}}=s;if("interval"===i)(t=>{const r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id "'.concat(t,'".'));clearTimeout(r),e.delete(t)})(o),postMessage({error:null,id:r});else{if("timeout"!==i)throw new Error('The given type "'.concat(i,'" is not supported'));(e=>{const r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(r),t.delete(e)})(o),postMessage({error:null,id:r})}}else{if("set"!==s.method)throw new Error('The given method "'.concat(s.method,'" is not supported'));{const{params:{delay:i,now:n,timerId:a,timerType:d}}=s;if("interval"===d)((t,i,s)=>{const{expected:n,remainingDelay:a}=r(t,s);e.set(i,setTimeout(o,a,e,i,n,"interval"))})(i,a,n);else{if("timeout"!==d)throw new Error('The given type "'.concat(d,'" is not supported'));((e,i,s)=>{const{expected:n,remainingDelay:a}=r(e,s);t.set(i,setTimeout(o,a,t,i,n,"timeout"))})(i,a,n)}}}}catch(e){postMessage({error:{message:e.message},id:s.id,result:null})}}))})();`;
var fe = Ke(Xe, Qe);
var Ze = (r) => fe().clearInterval(r);
var et = (r) => fe().clearTimeout(r);
var tt = (r, e) => fe().setInterval(r, e);
var rt = (r, e) => fe().setTimeout(r, e);
var x = (typeof window == "undefined" ? "undefined" : typeof window) == "object";
var E = { setTimeout: x ? setTimeout.bind(window) : setTimeout, clearTimeout: x ? clearTimeout.bind(window) : clearTimeout, setInterval: x ? setInterval.bind(window) : setInterval, clearInterval: x ? clearInterval.bind(window) : clearInterval };
var oe = { setTimeout: rt, clearTimeout: et, setInterval: tt, clearInterval: Ze };
function Ct() {
  E.setTimeout = setTimeout, E.clearTimeout = clearTimeout, E.setInterval = setInterval, E.clearInterval = clearInterval, oe.setTimeout = setTimeout, oe.clearTimeout = clearTimeout, oe.setInterval = setInterval, oe.clearInterval = clearInterval;
}
function nt(r) {
  E.setTimeout = r.setTimeout, E.clearTimeout = r.clearTimeout, E.setInterval = r.setInterval, E.clearInterval = r.clearInterval;
}
var X = {};
var it = class {
  constructor(e) {
    this.closed = false;
    this.mc = new MessageChannel();
    this.name = e, X[e] = X[e] || [], X[e].push(this), this.mc.port1.start(), this.mc.port2.start(), this.onStorage = this.onStorage.bind(this), window.addEventListener("storage", this.onStorage);
  }
  onStorage(e) {
    if (e.storageArea !== window.localStorage || e.key.substring(0, this.name.length) !== this.name || e.newValue === null)
      return;
    let n = JSON.parse(e.newValue);
    this.mc.port2.postMessage(n);
  }
  postMessage(e) {
    if (this.closed)
      throw new Error("InvalidStateError");
    let n = JSON.stringify(e), i = `${this.name}:${String(Date.now())}${String(Math.random())}`;
    window.localStorage.setItem(i, n), E.setTimeout(() => {
      window.localStorage.removeItem(i);
    }, 500), X[this.name].forEach((c) => {
      c !== this && c.mc.port2.postMessage(JSON.parse(n));
    });
  }
  close() {
    if (this.closed)
      return;
    this.closed = true, this.mc.port1.close(), this.mc.port2.close(), window.removeEventListener("storage", this.onStorage);
    let e = X[this.name].indexOf(this);
    X[this.name].splice(e, 1);
  }
  get onmessage() {
    return this.mc.port1.onmessage;
  }
  set onmessage(e) {
    this.mc.port1.onmessage = e;
  }
  get onmessageerror() {
    return this.mc.port1.onmessageerror;
  }
  set onmessageerror(e) {
    this.mc.port1.onmessageerror = e;
  }
  addEventListener(e, n) {
    return this.mc.port1.addEventListener(e, n);
  }
  removeEventListener(e, n) {
    return this.mc.port1.removeEventListener(e, n);
  }
  dispatchEvent(e) {
    return this.mc.port1.dispatchEvent(e);
  }
};
var ot = typeof window == "undefined" ? void 0 : typeof window.BroadcastChannel == "function" ? window.BroadcastChannel : it;
function st(r = 0) {
  return new Promise((e) => E.setTimeout(e, r));
}
function he() {
  return Math.random().toString(36).substring(2);
}
var a;
(function(o) {
  o[o.APPLY = 0] = "APPLY", o[o.TELL = 1] = "TELL", o[o.CLOSE = 2] = "CLOSE", o[o.REGISTER = 3] = "REGISTER", o[o.DEREGISTER = 4] = "DEREGISTER", o[o.IDLE = 5] = "IDLE", o[o.ACTIVE = 6] = "ACTIVE", o[o.PROMPT = 7] = "PROMPT", o[o.START = 8] = "START", o[o.RESET = 9] = "RESET", o[o.ACTIVATE = 10] = "ACTIVATE", o[o.PAUSE = 11] = "PAUSE", o[o.RESUME = 12] = "RESUME", o[o.MESSAGE = 13] = "MESSAGE";
})(a || (a = {}));
var Me = class {
  constructor(e, n) {
    this.token = he();
    this.isLeader = false;
    this.isDead = false;
    this.isApplying = false;
    this.reApply = false;
    this.intervals = [];
    this.listeners = [];
    this.channel = e, this.options = n, this.apply = this.apply.bind(this), this.awaitLeadership = this.awaitLeadership.bind(this), this.sendAction = this.sendAction.bind(this);
  }
  async apply() {
    if (this.isLeader || this.isDead)
      return false;
    if (this.isApplying)
      return this.reApply = true, false;
    this.isApplying = true;
    let e = false, n = (i) => {
      let { token: c, action: m } = i.data;
      c !== this.token && (m === a.APPLY && c > this.token && (e = true), m === a.TELL && (e = true));
    };
    this.channel.addEventListener("message", n);
    try {
      return this.sendAction(a.APPLY), await st(this.options.responseTime), this.channel.removeEventListener("message", n), this.isApplying = false, e ? this.reApply ? this.apply() : false : (this.assumeLead(), true);
    } catch {
      return false;
    }
  }
  awaitLeadership() {
    if (this.isLeader)
      return Promise.resolve();
    let e = false, n = null;
    return new Promise((i) => {
      let c = () => {
        if (e)
          return;
        e = true, E.clearInterval(n);
        let y = this.intervals.indexOf(n);
        this.intervals.splice(y, 1), this.channel.removeEventListener("message", m), i();
      };
      n = E.setInterval(() => {
        this.apply().then(() => {
          this.isLeader && c();
        });
      }, this.options.fallbackInterval), this.intervals.push(n);
      let m = (y) => {
        let { action: C } = y.data;
        C === a.CLOSE && this.apply().then(() => {
          this.isLeader && c();
        });
      };
      this.channel.addEventListener("message", m);
    });
  }
  sendAction(e) {
    this.channel.postMessage({ action: e, token: this.token });
  }
  assumeLead() {
    this.isLeader = true;
    let e = (n) => {
      let { action: i } = n.data;
      i === a.APPLY && this.sendAction(a.TELL);
    };
    return this.channel.addEventListener("message", e), this.listeners.push(e), this.sendAction(a.TELL);
  }
  waitForLeadership() {
    return this.deferred ? this.deferred : (this.deferred = this.awaitLeadership(), this.deferred);
  }
  close() {
    this.isDead || (this.isDead = true, this.isLeader = false, this.sendAction(a.CLOSE), this.listeners.forEach((e) => this.channel.removeEventListener("message", e)), this.intervals.forEach((e) => E.clearInterval(e)));
  }
};
var k;
(function(i) {
  i[i.PROMPTED = 0] = "PROMPTED", i[i.ACTIVE = 1] = "ACTIVE", i[i.IDLE = 2] = "IDLE";
})(k || (k = {}));
var xe = class {
  constructor(e) {
    this.token = he();
    this.registry = /* @__PURE__ */ new Map();
    this.allIdle = false;
    this.isLastActive = false;
    let { channelName: n } = e;
    if (this.options = e, this.channel = new ot(n), this.registry.set(this.token, 1), e.leaderElection) {
      let i = { fallbackInterval: 2e3, responseTime: 100 };
      this.elector = new Me(this.channel, i), this.elector.waitForLeadership();
    }
    this.channel.addEventListener("message", (i) => {
      let { action: c, token: m, data: y } = i.data;
      switch (c) {
        case a.REGISTER:
          this.registry.set(m, 2);
          break;
        case a.DEREGISTER:
          this.registry.delete(m);
          break;
        case a.IDLE:
          this.idle(m);
          break;
        case a.ACTIVE:
          this.active(m);
          break;
        case a.PROMPT:
          this.prompt(m);
          break;
        case a.START:
          this.start(m);
          break;
        case a.RESET:
          this.reset(m);
          break;
        case a.ACTIVATE:
          this.activate(m);
          break;
        case a.PAUSE:
          this.pause(m);
          break;
        case a.RESUME:
          this.resume(m);
          break;
        case a.MESSAGE:
          this.options.onMessage(y);
          break;
      }
    }), this.send(a.REGISTER);
  }
  get isLeader() {
    if (!this.elector)
      throw new Error('❌ Leader election is not enabled. To Enable it set the "leaderElection" property to true.');
    return this.elector.isLeader;
  }
  prompt(e = this.token) {
    this.registry.set(e, 0);
    let n = [...this.registry.values()].every((i) => i === 0);
    e === this.token && this.send(a.PROMPT), n && this.options.onPrompt();
  }
  idle(e = this.token) {
    this.registry.set(e, 2);
    let n = [...this.registry.values()].every((i) => i === 2);
    e === this.token && this.send(a.IDLE), !this.allIdle && n && (this.allIdle = true, this.options.onIdle());
  }
  active(e = this.token) {
    this.allIdle = false, this.registry.set(e, 1);
    let n = [...this.registry.values()].some((i) => i === 1);
    e === this.token && this.send(a.ACTIVE), n && this.options.onActive(), this.isLastActive = e === this.token;
  }
  start(e = this.token) {
    this.allIdle = false, this.registry.set(e, 1), e === this.token ? this.send(a.START) : this.options.start(true), this.isLastActive = e === this.token;
  }
  reset(e = this.token) {
    this.allIdle = false, this.registry.set(e, 1), e === this.token ? this.send(a.RESET) : this.options.reset(true), this.isLastActive = e === this.token;
  }
  activate(e = this.token) {
    this.allIdle = false, this.registry.set(e, 1), e === this.token ? this.send(a.ACTIVATE) : this.options.activate(true), this.isLastActive = e === this.token;
  }
  pause(e = this.token) {
    e === this.token ? this.send(a.PAUSE) : this.options.pause(true);
  }
  resume(e = this.token) {
    e === this.token ? this.send(a.RESUME) : this.options.resume(true);
  }
  message(e) {
    try {
      this.channel.postMessage({ action: a.MESSAGE, token: this.token, data: e });
    } catch {
    }
  }
  send(e) {
    try {
      this.channel.postMessage({ action: e, token: this.token });
    } catch {
    }
  }
  close() {
    this.options.leaderElection && this.elector.close(), this.send(a.DEREGISTER), this.channel.close();
  }
};
var at = x ? document : null;
var Ae = ["mousemove", "keydown", "wheel", "DOMMouseScroll", "mousewheel", "mousedown", "touchstart", "touchmove", "MSPointerDown", "MSPointerMove", "visibilitychange", "focus"];
function ct(r, e) {
  let n;
  function i(...c) {
    n && clearTimeout(n), n = setTimeout(() => {
      r(...c), n = null;
    }, e);
  }
  return i.cancel = function() {
    clearTimeout(n);
  }, i;
}
function ve(r, e) {
  let n = 0;
  return function(...i) {
    let c = new Date().getTime();
    if (!(c - n < e))
      return n = c, r(...i);
  };
}
var T = () => Date.now();
var K = 2147483647;
function re({ timeout: r = 1e3 * 60 * 20, promptTimeout: e = 0, promptBeforeIdle: n = 0, element: i = at, events: c = Ae, timers: m = void 0, immediateEvents: y = [], onPresenceChange: C = () => {
}, onPrompt: W = () => {
}, onIdle: p = () => {
}, onActive: l = () => {
}, onAction: f = () => {
}, onMessage: d = () => {
}, debounce: h = 0, throttle: o = 0, eventsThrottle: B = 200, startOnMount: w = true, startManually: _ = false, stopOnIdle: se = false, crossTab: Y = false, name: Se = "idle-timer", syncTimers: Q = 0, leaderElection: Oe = false } = {}) {
  let Ce = (0, import_react2.useRef)(T()), ae = (0, import_react2.useRef)(T()), L = (0, import_react2.useRef)(null), A = (0, import_react2.useRef)(null), H = (0, import_react2.useRef)(0), Z = (0, import_react2.useRef)(0), R = (0, import_react2.useRef)(0), M = (0, import_react2.useRef)(0), v = (0, import_react2.useRef)(false), b = (0, import_react2.useRef)(false), D = (0, import_react2.useRef)(false), F = (0, import_react2.useRef)(true), ee = (0, import_react2.useRef)(false), N = (0, import_react2.useRef)(null), s = (0, import_react2.useRef)(null), S = (0, import_react2.useRef)(r), V = (0, import_react2.useRef)(0);
  (0, import_react2.useEffect)(() => {
    if (e && console.warn("⚠️ IdleTimer -- The `promptTimeout` property has been deprecated in favor of `promptBeforeIdle`. It will be removed in the next major release."), n && e)
      throw new Error("❌ Both promptTimeout and promptBeforeIdle can not be set. The promptTimeout property will be deprecated in a future version.");
    if (r >= K)
      throw new Error(`❌ The value for the timeout property must fit in a 32 bit signed integer, ${K}.`);
    if (e >= K)
      throw new Error(`❌ The value for the promptTimeout property must fit in a 32 bit signed integer, ${K}.`);
    if (n >= K)
      throw new Error(`❌ The value for the promptBeforeIdle property must fit in a 32 bit signed integer, ${K}.`);
    if (n ? (S.current = r - n, V.current = n) : (S.current = r, V.current = e), !F.current) {
      if (_)
        return;
      v.current && ($.current(), s.current && s.current.active()), z();
    }
  }, [r, e, n, _]);
  let Re = (0, import_react2.useRef)(se);
  (0, import_react2.useEffect)(() => {
    Re.current = se;
  }, [se]);
  let De = (0, import_react2.useRef)(y), Ie = (0, import_react2.useRef)(i), Ee = (0, import_react2.useRef)([...(/* @__PURE__ */ new Set([...c, ...y])).values()]), te = (0, import_react2.useRef)(C);
  (0, import_react2.useEffect)(() => {
    te.current = C;
  }, [C]);
  let ce = (0, import_react2.useRef)(W);
  (0, import_react2.useEffect)(() => {
    ce.current = W;
  }, [W]);
  let le = (0, import_react2.useRef)(p);
  (0, import_react2.useEffect)(() => {
    le.current = p;
  }, [p]);
  let $ = (0, import_react2.useRef)(l);
  (0, import_react2.useEffect)(() => {
    $.current = l;
  }, [l]);
  let ue = (0, import_react2.useRef)(f);
  (0, import_react2.useEffect)(() => {
    ue.current = f;
  }, [f]);
  let J = (0, import_react2.useRef)(d);
  (0, import_react2.useEffect)(() => {
    J.current = d;
  }, [d]);
  let G = (0, import_react2.useMemo)(() => {
    let t = (P) => ue.current(P);
    return h > 0 ? ct(t, h) : o > 0 ? ve(t, o) : t;
  }, [o, h]), Ne = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(() => {
    Y && Q && (Ne.current = ve(() => {
      s.current.active();
    }, Q));
  }, [Y, Q]);
  let O = () => {
    N.current !== null && (E.clearTimeout(N.current), N.current = null);
  }, q = (t, P = true) => {
    O(), N.current = E.setTimeout(ge, t || S.current), P && (A.current = T());
  }, _e = (t) => {
    !b.current && !v.current && (ce.current(t), te.current({ type: "active", prompted: true })), M.current = 0, R.current = T(), b.current = true, q(V.current, false);
  }, He = () => {
    O(), v.current || (le.current(), te.current({ type: "idle" })), v.current = true, L.current = T(), Re.current ? j() : b.current && (R.current = 0, b.current = false);
  }, be = (t) => {
    O(), (v.current || b.current) && ($.current(t), te.current({ type: "active", prompted: false })), b.current = false, R.current = 0, v.current = false, H.current += T() - L.current, Z.current += T() - L.current, U(), q();
  }, ge = (t) => {
    if (!v.current) {
      G.cancel && G.cancel();
      let de = T() - A.current;
      if (!(S.current + V.current < de) && V.current > 0 && !b.current) {
        s.current ? s.current.prompt() : _e(t);
        return;
      }
      s.current ? s.current.idle() : He();
      return;
    }
    s.current ? s.current.active() : be(t);
  }, ye = (t) => {
    if (!w && !A.current && (A.current = T(), $.current()), G(t), b.current)
      return;
    if (O(), !v.current && De.current.includes(t.type)) {
      ge(t);
      return;
    }
    let P = T() - A.current;
    if (v.current && !se || !v.current && P >= S.current) {
      ge(t);
      return;
    }
    D.current = false, M.current = 0, R.current = 0, q(), Y && Q && Ne.current();
  }, me = (0, import_react2.useRef)(ye);
  (0, import_react2.useEffect)(() => {
    let t = ee.current;
    t && j(), B > 0 ? me.current = ve(ye, B) : me.current = ye, t && U();
  }, [B, o, h, ue, Y, Q]);
  let U = () => {
    !x || ee.current || (Ee.current.forEach((t) => {
      Ie.current.addEventListener(t, me.current, { capture: true, passive: true });
    }), ee.current = true);
  }, j = (t = false) => {
    !x || (ee.current || t) && (Ee.current.forEach((P) => {
      Ie.current.removeEventListener(P, me.current, { capture: true });
    }), ee.current = false);
  }, z = (0, import_react2.useCallback)((t) => {
    O(), U(), v.current = false, b.current = false, D.current = false, M.current = 0, R.current = 0, s.current && !t && s.current.start(), q();
  }, [N, v, S, s]), we = (0, import_react2.useCallback)((t) => {
    O(), U(), ae.current = T(), H.current += T() - L.current, Z.current += T() - L.current, H.current = 0, v.current = false, b.current = false, D.current = false, M.current = 0, R.current = 0, s.current && !t && s.current.reset(), _ || q();
  }, [N, v, S, _, s]), Fe = (0, import_react2.useCallback)((t) => {
    O(), U(), (v.current || b.current) && be(), v.current = false, b.current = false, D.current = false, M.current = 0, R.current = 0, ae.current = T(), s.current && !t && s.current.activate(), q();
  }, [N, v, b, S, s]), Le = (0, import_react2.useCallback)((t = false) => D.current ? false : (M.current = Ue(), D.current = true, j(), O(), s.current && !t && s.current.pause(), true), [N, s]), Pe = (0, import_react2.useCallback)((t = false) => D.current ? (D.current = false, b.current || U(), v.current || q(M.current), R.current && (R.current = T()), s.current && !t && s.current.resume(), true) : false, [N, S, M, s]), lt = (0, import_react2.useCallback)((t, P) => {
    s.current ? (P && J.current(t), s.current.message(t)) : P && J.current(t);
  }, [d]), ut = (0, import_react2.useCallback)(() => v.current, [v]), mt = (0, import_react2.useCallback)(() => b.current, [b]), dt = (0, import_react2.useCallback)(() => s.current ? s.current.isLeader : null, [s]), pt = (0, import_react2.useCallback)(() => s.current ? s.current.isLastActive : null, [s]), ft = (0, import_react2.useCallback)(() => s.current ? s.current.token : null, [s]), Ue = (0, import_react2.useCallback)(() => {
    if (D.current)
      return M.current;
    let t = M.current ? M.current : V.current + S.current, P = A.current ? T() - A.current : 0, de = Math.floor(t - P);
    return de < 0 ? 0 : Math.abs(de);
  }, [S, V, b, M, A]), We = (0, import_react2.useCallback)(() => Math.round(T() - ae.current), [ae]), Be = (0, import_react2.useCallback)(() => Math.round(T() - Ce.current), [Ce]), ht = (0, import_react2.useCallback)(() => L.current ? new Date(L.current) : null, [L]), vt = (0, import_react2.useCallback)(() => A.current ? new Date(A.current) : null, [A]), Ve = (0, import_react2.useCallback)(() => v.current ? Math.round(T() - L.current + H.current) : Math.round(H.current), [L, H]), Ge = (0, import_react2.useCallback)(() => v.current ? Math.round(T() - L.current + Z.current) : Math.round(Z.current), [L, Z]), Tt = (0, import_react2.useCallback)(() => {
    let t = Math.round(We() - Ve());
    return t >= 0 ? t : 0;
  }, [L, H]), It = (0, import_react2.useCallback)(() => {
    let t = Math.round(Be() - Ge());
    return t >= 0 ? t : 0;
  }, [L, H]);
  return (0, import_react2.useEffect)(() => {
    if (h > 0 && o > 0)
      throw new Error("❌ onAction can either be throttled or debounced, not both.");
    m && nt(m);
    let t = () => {
      s.current && s.current.close(), G.cancel && G.cancel(), O(), j(true);
    };
    return x && window.addEventListener("beforeunload", t), () => {
      x && window.removeEventListener("beforeunload", t), s.current && s.current.close(), G.cancel && G.cancel(), O(), j(true);
    };
  }, []), (0, import_react2.useEffect)(() => {
    s.current && s.current.close(), Y ? s.current = new xe({ channelName: Se, leaderElection: Oe, onPrompt: () => {
      _e();
    }, onIdle: () => {
      He();
    }, onActive: () => {
      be();
    }, onMessage: (...t) => {
      J.current(...t);
    }, start: z, reset: we, activate: Fe, pause: Le, resume: Pe }) : s.current = null;
  }, [Y, Se, Oe, ce, le, $, J, z, we, Le, Pe]), (0, import_react2.useEffect)(() => {
    F.current || (O(), j(true)), !_ && (w ? z() : U());
  }, [_, w, F]), (0, import_react2.useEffect)(() => {
    if (!F.current) {
      let t = [...(/* @__PURE__ */ new Set([...c, ...y])).values()];
      if (j(), Ee.current = t, Ie.current = i, De.current = y, _)
        return;
      w ? z() : U();
    }
  }, [i, JSON.stringify(c), JSON.stringify(y), F, _, w]), (0, import_react2.useEffect)(() => {
    F.current && (F.current = false);
  }, [F]), { message: lt, start: z, reset: we, activate: Fe, pause: Le, resume: Pe, isIdle: ut, isPrompted: mt, isLeader: dt, isLastActiveTab: pt, getTabId: ft, getRemainingTime: Ue, getElapsedTime: We, getTotalElapsedTime: Be, getLastIdleTime: ht, getLastActiveTime: vt, getIdleTime: Ve, getTotalIdleTime: Ge, getActiveTime: Tt, getTotalActiveTime: It, setOnPresenceChange: (t) => {
    C = t, te.current = t;
  }, setOnPrompt: (t) => {
    W = t, ce.current = t;
  }, setOnIdle: (t) => {
    p = t, le.current = t;
  }, setOnActive: (t) => {
    l = t, $.current = t;
  }, setOnAction: (t) => {
    f = t, ue.current = t;
  }, setOnMessage: (t) => {
    d = t, J.current = t;
  } };
}
var Te = (0, import_react3.createContext)(null);
function Ht(r) {
  let e = re(r);
  return import_react3.default.createElement(Te.Provider, { value: e }, r.children);
}
var Ft = Te.Consumer;
function Ut() {
  return (0, import_react3.useContext)(Te);
}
export {
  Ae as DEFAULT_EVENTS,
  je as IdleTimerComponent,
  Ft as IdleTimerConsumer,
  Te as IdleTimerContext,
  Ht as IdleTimerProvider,
  Ct as createMocks,
  re as useIdleTimer,
  Ut as useIdleTimerContext,
  Ot as withIdleTimer,
  oe as workerTimers
};
//# sourceMappingURL=react-idle-timer.js.map
